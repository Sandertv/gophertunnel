// Code generated by protocol/packet generator; DO NOT EDIT.
// Generated at:       2025-12-12T23:58:34Z
// Minecraft version:  1.21.130
// Protocol version:   897
// Packet ID:          328 (0x148)

package packet

import (
	"github.com/go-gl/mathgl/mgl32"
	"github.com/sandertv/gophertunnel/minecraft/protocol"
)

// ShapeDataPayload is a nested struct used in the packet.
type ShapeDataPayload struct {
	// NetworkID uint64 network id used to identify the matching shape on the client as the server
	NetworkID uint64
	// ShapeType Byte representing the type of debug shape (Line, Box, Sphere, Circle, Text).
	ShapeType uint8
	// Location Vec3 location of the debug shape in the world.
	Location mgl32.Vec3
	// Scale Float scale of the debug shape in the world.
	Scale float32
	// Rotation Vec3 (Euler angles in radians, PYR) rotation of the debug shape in the world.
	Rotation mgl32.Vec3
	// TotalTimeLeft The total time left in seconds until this debug shape will be removed (0 meaning never).
	TotalTimeLeft float32
	// Color Color (ARGB Hex string) of the debug shape.
	Color int32
	// DimensionID Currently supported: (0 -> Overworld, 1 -> Nether, 2 -> The End, 3 -> Undefined)
	DimensionID int32
	// ExtraShapeData Extra payload (variant) holding data specific to the type of shape (such as text string for the text shape).
	ExtraShapeData any
}

func (x *ShapeDataPayload) Marshal(r protocol.IO) {
	r.Varuint64(&x.NetworkID)
	r.Uint8(&x.ShapeType)
	r.Vec3(&x.Location)
	r.Float32(&x.Scale)
	r.Vec3(&x.Rotation)
	r.Float32(&x.TotalTimeLeft)
	r.Int32(&x.Color)
	r.Varint32(&x.DimensionID)
	switch val := x.ExtraShapeData.(type) {
	case nil:
		var typeID uint32 = 0
		r.Uint32(&typeID)
		_ = val // nil value, nothing more to write
	}
}

// DebugDrawer Send debug drawing shape info (from scripting) to the client for rendering
type DebugDrawer struct {
	// ArrayOfDebugShapes Semantic version string
	ArrayOfDebugShapes []ShapeDataPayload
}

// ID ...
func (*DebugDrawer) ID() uint32 {
	return IDDebugDrawer
}

func (pk *DebugDrawer) Marshal(io protocol.IO) {
	protocol.Slice(io, &pk.ArrayOfDebugShapes)
}
