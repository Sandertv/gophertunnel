// Code generated by protocol/packet generator; DO NOT EDIT.
// Generated at:       2025-12-12T23:58:34Z
// Minecraft version:  1.21.130
// Protocol version:   897
// Packet ID:          76 (0x4C)

package packet

import (
	"github.com/sandertv/gophertunnel/minecraft/protocol"
)

// ConstrainedValueData is a nested struct used in the packet.
type ConstrainedValueData struct {
	// EnumValueSymbol The enum value symbol.
	EnumValueSymbol uint32
	// EnumSymbol The enum symbol.
	EnumSymbol uint32
	// ConstraintIndices The constraint indices.
	ConstraintIndices []uint8
}

func (x *ConstrainedValueData) Marshal(r protocol.IO) {
	r.Uint32(&x.EnumValueSymbol)
	r.Uint32(&x.EnumSymbol)
	protocol.FuncSlice(r, &x.ConstraintIndices, r.Uint8)
}

// EnumData is a nested struct used in the packet.
type EnumData struct {
	// Name The name.
	Name string
	// Values The subcommand values.
	Values []uint32
}

func (x *EnumData) Marshal(r protocol.IO) {
	r.String(&x.Name)
	protocol.FuncSlice(r, &x.Values, r.Uint32)
}

// SoftEnumData is a nested struct used in the packet.
type SoftEnumData struct {
	// EnumName The enum name.
	EnumName string
	// EnumOptions The enum options.
	EnumOptions []string
}

func (x *SoftEnumData) Marshal(r protocol.IO) {
	r.String(&x.EnumName)
	protocol.FuncSlice(r, &x.EnumOptions, r.String)
}

// ChainedSubcommandRelationship is a nested struct used in the packet.
type ChainedSubcommandRelationship struct {
	// SubCommandFirstValue The first value, the sub command value id.
	SubCommandFirstValue uint32
	// SubCommandSecondValue The second value, the enum id.
	SubCommandSecondValue uint32
}

func (x *ChainedSubcommandRelationship) Marshal(r protocol.IO) {
	r.Varuint32(&x.SubCommandFirstValue)
	r.Varuint32(&x.SubCommandSecondValue)
}

// ChainedSubcommandData is a nested struct used in the packet.
type ChainedSubcommandData struct {
	// Name The name.
	Name string
	// SubCommandValues The subcommand values.
	SubCommandValues []ChainedSubcommandRelationship
}

func (x *ChainedSubcommandData) Marshal(r protocol.IO) {
	r.String(&x.Name)
	protocol.Slice(r, &x.SubCommandValues)
}

// ParamData is a nested struct used in the packet.
type ParamData struct {
	// Name The parameter name.
	Name string
	// ParseSymbol The parameter parse symbol.
	ParseSymbol uint32
	// IsOptional The parameter optional flag. True for an optional parameter.
	IsOptional bool
	// Options The parameter options.
	Options uint8
}

func (x *ParamData) Marshal(r protocol.IO) {
	r.String(&x.Name)
	r.Uint32(&x.ParseSymbol)
	r.Bool(&x.IsOptional)
	r.Uint8(&x.Options)
}

// OverloadData is a nested struct used in the packet.
type OverloadData struct {
	// IsChaining The is chaining command flag, true for chaining.
	IsChaining bool
	// ParameterData The parameters data.
	ParameterData []ParamData
}

func (x *OverloadData) Marshal(r protocol.IO) {
	r.Bool(&x.IsChaining)
	protocol.Slice(r, &x.ParameterData)
}

// CommandData is a nested struct used in the packet.
type CommandData struct {
	// Name The name.
	Name string
	// Description The command description.
	Description string
	// Flags The command flags.
	Flags uint16
	// PermissionLevel The command permission level.
	PermissionLevel uint8
	// AliasEnum The command alias enum.
	AliasEnum int32
	// CommandDataChainedSubcommandIndexes The command chained subcommand indexes.
	CommandDataChainedSubcommandIndexes []uint32
	// Overloads The command overloads data.
	Overloads []OverloadData
}

func (x *CommandData) Marshal(r protocol.IO) {
	r.String(&x.Name)
	r.String(&x.Description)
	r.Uint16(&x.Flags)
	r.Uint8(&x.PermissionLevel)
	r.Int32(&x.AliasEnum)
	protocol.FuncSlice(r, &x.CommandDataChainedSubcommandIndexes, r.Uint32)
	protocol.Slice(r, &x.Overloads)
}

// AvailableCommands Contains all the available commands.
type AvailableCommands struct {
	// EnumValues The enum values.
	EnumValues []string
	// ChainedSubcommandValues The chained subcommand values.
	ChainedSubcommandValues []string
	// PostFixes The post fixes.
	PostFixes []string
	// EnumData The enum data.
	EnumData []EnumData
	// ChainedSubcommandData The chained subcommand data.
	ChainedSubcommandData []ChainedSubcommandData
	// Commands The commands data.
	Commands []CommandData
	// SoftEnums The soft enums data.
	SoftEnums []SoftEnumData
	// Constraints The constraints data.
	Constraints []ConstrainedValueData
}

// ID ...
func (*AvailableCommands) ID() uint32 {
	return IDAvailableCommands
}

func (pk *AvailableCommands) Marshal(io protocol.IO) {
	protocol.FuncSlice(io, &pk.EnumValues, io.String)
	protocol.FuncSlice(io, &pk.ChainedSubcommandValues, io.String)
	protocol.FuncSlice(io, &pk.PostFixes, io.String)
	protocol.Slice(io, &pk.EnumData)
	protocol.Slice(io, &pk.ChainedSubcommandData)
	protocol.Slice(io, &pk.Commands)
	protocol.Slice(io, &pk.SoftEnums)
	protocol.Slice(io, &pk.Constraints)
}
